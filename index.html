<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Meilinv77.GitHub.io by Meilinv77</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Meilinv77.GitHub.io</h1>
      <h2 class="project-tagline">77博客</h2>
    </section>

    <section class="main-content">
      <p>Portal初识</br></br></br>

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近遇到了项目上接触到Portal，我们产品使用JetSpeed作为Portal的实现。于是自己研究了下Jetspeed。</br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先学一门新东西需要知道他能用来做什么：Jetspeed是基于Web的应用，通常提供个性化，单点登录，
整合不同资源的综合信息展示平台。其他的定义就不在赘述了，值得一提的是Jetspeed能把系统做成类似客户端的桌面系统，用户体验效果不错。
从JSR168规范来看Jetspeed主要实现了Portal--Portlet Container--Portlet概念中的Portal。
它是连接用户与各个模块组件的桥梁。整个调用流程再次不在详解，项目文档中也已经说的十分详细。
这里主要谈谈Jetspeed的核心组件。结合着Jetspeed架构图已经源代码先把Jetspeed核心组件抛出来。   </br>   
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1).Engine</br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).Container</br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).Pipeline</br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4).Valve</br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Engine是整个项目的核心。从源码包中可以看到它里面主要包含两个类 </br></br>
  
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.apache.jetspeed.engine.JetspeedEngine </br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.apache.jetspeed.engine.JetspeedServlet </br>
  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中JetspeedServlet是整个框架的入口。项目启动会立即执行JetspeedServlet，在其init方法中进行JetspeedEngine的初始化工作，
  即engine = new JetspeedEngine(properties, applicationRoot, config, initializeComponentManager(config, applicationRoot, properties));
然后用户就可以通过http协议来呼叫JetspeedEngine的service方法去进行交互。其实service所做的具体工作就是根据请求中的参数调用各个管道JetspeedPipeline接下来说下管道。
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JetspeedPipeline按照设计模式中职责链模式设计，它其实就跟Servlet中的Filter很类似。从代码中可以看出它的实现也是利用了Java的反射机制</p>
    <pre><code>
    public void invoke(RequestContext request) throws PipelineException
      {
        try
        {
            Invocation invocation;
            synchronized (this)
            {
                invocation = new Invocation(valves);
            }
            // Invoke the first Valve in this pipeline for this request
            invocation.invokeNext(request);
        }
        finally
        {
            // Invoke all cleanup valves swallowing any thrown exceptions
            // for this request
            Valve[] invokeCleanupValves;
            synchronized (this)
            {
                invokeCleanupValves = copyValveArray(cleanupValves);
            }
            for (int i = 0; (i < invokeCleanupValves.length); i++)
            {
                Invocation cleanupInvocation = new Invocation(invokeCleanupValves[i]);
                try
                {
                    cleanupInvocation.invokeNext(request);
                }
                catch (Throwable t)
                {
                }
            }
        }
    }
    </code></pre>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JetspeedPipeline传递了RequestContext将具体的业务处理交给了各个阀门Valve，每个阀门处理完在将处理后的信息塞到RequestContext参数中如果有下一个阀门等待处理再去调用下一个。JetspeedPipeline中内置了 
15个阀门。如果我们想扩展自己的阀门非常Easy只需要实现org.apache.jetspeed.pipeline.valve.Valve接口，然后在管道中我们可以通过调用</br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void addValve(Valve valve); 去增加一个新的阀门</br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void invoke(RequestContext context) 来调用下一个阀门</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阀门调用过程中可能会与Container交互去处理相关的Portlet，最后一个阀门调用结束将处理结果返回Pipeline,回写给用户。需要强调的是这里的Container并不是Web容器，它是Portlet容器。
    Jetspeed有些地方集成了第三方插件，如Jetspeed 组件的生命周期和依赖关系由spring托管。这是一个很好的思想,很多开源框架也都是如此遵循SPI插件化规范。将部分业务交个更擅长，做的更好的开源组织去实现,而自己只需要关系核心业务的处理，这样用到时只需要考虑去兼容这些外部业务就行了。比如分布式框架Dubbo 很多模块都用到第三方插件去实现，如注册中心交给Zookeeper、协议扩展化，而自己去解决核心集群容错，软负载均衡，路由规则等问题。这些思想也非常值得我们思考去用在我们自己的产品中。</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
